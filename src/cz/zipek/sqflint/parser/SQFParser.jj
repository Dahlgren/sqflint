options {
	IGNORE_CASE = true;
	ERROR_REPORTING = true;
	DEBUG_PARSER = false;
	STATIC = false;
}

PARSER_BEGIN(SQFParser)

package cz.zipek.sqflint.parser;

import cz.zipek.sqflint.SQFArray;
import cz.zipek.sqflint.SQFBlock;
import cz.zipek.sqflint.SQFIdentifier;
import cz.zipek.sqflint.SQFLiteral;
import cz.zipek.sqflint.SQFUnit;

public class SQFParser {
	public void setTabSize(int size) {
		jj_input_stream.setTabSize(size);
	}

	protected void handleName() throws ParseException {}
	protected void handleParams(SQFArray contents) throws ParseException {}

	protected int recover(ParseException ex, int target) throws ParseException {
		return recover(ex, target, false);
	}

	protected int recover(ParseException ex, int target, boolean skip) throws ParseException {
		return target;
	}
}

PARSER_END(SQFParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
| "#" : PREPROCESSOR_OUTPUT
}

<PREPROCESSOR_OUTPUT> SKIP:
{
     "\n" : DEFAULT
}

<PREPROCESSOR_OUTPUT> MORE:
{
	"\\\n" |
	"\\\r\n" |
	< ~[] >
}


/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* OPERATORS */

TOKEN :
{
	< ASSIGN: "=" >    |
	< GT: ">" >        |
	< LT: "<" >        |
	< GTEQ: ">=" > |
	< LTEQ: "<=" > |
	< BANG: "!" >      |
	< BANG2: "not " >  |
	< EQ: "==" >       |
	< SC_OR: "||" >    |
	< SC_AND: "&&" >   |
	< PLUS: "+" >      |
	< MINUS: "-" >     |
	< STAR: "*" >      |
	< SLASH: "/" >     |
	< POWER: "^" >     |
	< REM: "%" >       |
	< REM2: "mod" > |
	< CSEL: ">>" >
}

/* SQF Operators */

/* RESERVED */

TOKEN :
{
	< CASE: "case" > |
	< CATCH: "catch" > |
	< _DEFAULT: "default" > |
	< DO: "do" > |
	< ELSE: "else" > |
	< FOR: "for" > |
	< FROM: "from" > |
	< TO: "to" > |
	< STEP: "step" > |
	< GOTO: "goto" > |
	< IF: "if" > |
	< THEN: "then" > |
	< EXIT_WITH: "exitWith" > |
	< SWITCH: "switch" > |
	< WHILE: "while" > |
	< TRUE: "true" > |
	< FALSE: "false" > |
	< PARAMS: "params" >

}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  > |
  < #DECIMAL_LITERAL: ("-")? ["1"-"9"] (["0"-"9"])* > |
  < #HEX_LITERAL: ("-")? "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ > |
  < #OCTAL_LITERAL: ("-")? "0" (["0"-"7"])* > |
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
      | "." (["0"-"9"])+ (<EXPONENT>)? 
      | (["0"-"9"])+ <EXPONENT>
      | (["0"-"9"])+ (<EXPONENT>)?
  > |
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ > |
  < STRING_LITERAL:
      "\""
      ( "\"\"" | (~["\""]) )*
      "\""
  > |
  < STRING_LITERAL_OTHER:
      "'"
      ( (~["\'","\\"]) )*
      "'"
  >
}

/* IDENTIFIERS */

TOKEN :
{
	< IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* > |
	<#LETTER: ["A"-"Z","_","a"-"z"]> |
	<#DIGIT: ["0"-"9"]>
}

/* SEPARATORS */

TOKEN :
{
	< LPAREN: "(" >    |
	< RPAREN: ")" >    |
	< LBRACE: "{" >    |
	< RBRACE: "}" >    |
	< LBRACKET: "[" >  |
	< RBRACKET: "]" >  |
	< COMMA: "," >     |
	< DOT: "." > |
	< SEMICOLON: ";" >
}


/*

============ END OF TOKENS =============
============ START OF LANG =============

*/


void CompilationUnit() :
{}
{
	try {
		BlockContents()
		<EOF>
	} catch (ParseException ex) {
		if (recover(ex, SEMICOLON, true) != EOF) {
			CompilationUnit();
		}
	}
}


SQFLiteral Literal() :
{
	Token contents = null;
}
{
	contents = <INTEGER_LITERAL> { return new SQFLiteral(contents); } |
	contents = <FLOATING_POINT_LITERAL> { return new SQFLiteral(contents); } |
	contents = <STRING_LITERAL> { return new SQFLiteral(contents); } |
	contents = <STRING_LITERAL_OTHER> { return new SQFLiteral(contents); } |
	contents = BooleanLiteral() { return new SQFLiteral(contents); }
}

Token BooleanLiteral() :
{
	Token result = null;
}
{
	result = "true" { return result; }  |
	result = "false" { return result; }
}

void Operator() :
{}
{
	">>" |
	"=" |
	"==" |
	"!=" |
	">" |
	"<" |
	"+" |
	"-" |
	"*" |
	"%" |
	"&&" |
	"||" |
	"mod" |
	"^" |
	">=" |
	"<=" |
	"/"
}

SQFIdentifier Name() :
{
	Token token = null;

	handleName();
}
{
	token = <IDENTIFIER>

	{ return new SQFIdentifier(token); }
}

SQFUnit Expression() :
{
	SQFUnit result = null;
}
{
	("!" | "not ") result = Expression() { return result; } |
	result = PrimaryExpression() [ Operator() ] [ result = Expression() ] { return result; }
}

SQFArray Array() :
{
	SQFArray array = new SQFArray();
	SQFUnit item = null;
}
{
	LOOKAHEAD(2) "[" item = Expression() { array.add(item); } ( "," item = Expression() { array.add(item); } )* "]" { return array; } |
	"[" "]" 	{ return array; }
}

SQFUnit PrimaryExpression() :
{
	SQFUnit result = null;
}
{
	result = Literal() { return result; }  |
	"(" result = Expression() ")" { return result; } |
	result = Name() { return result; } |
	result = Block() { return result; } |
	result = Array() { return result; }
}

SQFBlock Block() :
{
	SQFBlock result = new SQFBlock();
}
{
	LOOKAHEAD(2)
	"{" result = BlockContents() "}" { return result; } |
	"{" "}" { return result; }
}

SQFBlock BlockContents():
{
	SQFBlock result = new SQFBlock();
	SQFUnit statement = null;
}
{
	statement = Statement() { result.add(statement); }
	( ";" [ statement = Statement() { result.add(statement); }  ] )*
	{ return result; }
}

SQFUnit BlockStatement():
{
	SQFUnit result = null;
}
{
	// @TODO: Fact that statement begins with ";" breaks the recovery
	try {
		/*EmptyStatement() { return result; } |*/
		";" [ result = Statement() ]
	} catch(ParseException ex) {
		recover(ex, SEMICOLON);
	}

	{ return result; }
}

SQFUnit Statement() :
{
	SQFUnit result = null;
}
{
	try {
		LOOKAHEAD(3)
		SwitchStatement() { return result; } |
		IfStatement() { return result; } |
		WhileStatement() { return result; } |
		ForStatement() { return result; } |
		ParamsStatement() { return result; } |
		result = StatementExpression() 	{ return result; }
	} catch(ParseException ex) {
		recover(ex, SEMICOLON);
	} finally {
		return null;
	}
}

void EmptyStatement() :
{}
{
  ";"
}

void ParamsStatement() :
{
	SQFArray contents = null;
}
{
	"params" contents = Array()
	{
		handleParams(contents);
	}
}

SQFUnit StatementExpression() :
{
	SQFUnit result = null;
}
{
	result = Expression() { return result; }
}

void SwitchStatement() :
{}
{
	"switch" Expression() "do" "{"
		( SwitchCase() )*
		[ SwitchDefault() ]
	"}"
}

void SwitchCase() :
{}
{
	SwitchLabel() ( ( ":" Block() ";" ) | ";" )
}

void SwitchDefault() :
{}
{
	"default" Block() ";"
}

void SwitchLabel() :
{}
{
	"case" Expression()
}

// @TODO: exitWith can't have else :(
void IfStatement() :
{}
{
	"if" Expression() (
		"then" Block() [ LOOKAHEAD(1) "else" Block() ] |
		"exitWith" Block()
	)
}

void WhileStatement() :
{}
{
	"while" Block() "do" Block()
}

void ForStatement() :
{}
{
	LOOKAHEAD(2) ( "for" "[" Block() "," Block() "," Block() "]" "do" Block() ) |
	LOOKAHEAD(2) ( "for" StatementExpression() "from" Expression() "to" Expression() [ "step" Expression() ] "do" Block() )
}